<div dir="rtl" style="font-size:60px; color:yellow">
فصل اول
</div>

<br/>
<div dir="rtl" style="font-size:28px;  color:yellow">
مفهوم Scale Cube
</div>

<div dir="rtl" style="font-size:28px">

مکعب مقیاس (Scale Cube) یک مدل سه‌بعدی برای مقیاس‌پذیری است که توسط Martin Abbott و Michael Fisher در کتاب The Art of Scalability معرفی شده است. این مدل به سه بعد اصلی برای مقیاس‌پذیری یک سیستم اشاره دارد:
</div>

![img_2.png](img_2.png)

<br/>

<div dir="rtl" style="font-size:28px">
1- مقیاس‌پذیری افقی (x-axis) یا Horizontal Scaling:
</div>

<br/>

<div dir="rtl" style="font-size:28px">
مقیاس‌پذیری محور X یک روش رایج برای مقیاس‌پذیری برنامه‌های یکپارچه (Monolithic) است. در این روش، چندین نمونه از برنامه را پشت یک لود بالانسر (Load Balancer) اجرا می‌کنید. لود بالانسر درخواست‌ها را بین N نمونه یکسان از برنامه توزیع می‌کند. این روش، راهی عالی برای بهبود ظرفیت و در دسترس بودن برنامه است.
</div>

![img.png](img.png)

<br/>
<div dir="rtl" style="font-size:28px">
2- Z-axis (عمق) - مقیاس‌پذیری مبتنی بر تقسیم (Decomposition Scaling)
</div>

<br/>

<div dir="rtl" style="font-size:28px">
در مقیاس‌پذیری محور Z نیز چندین نمونه از برنامه یکپارچه اجرا می‌شود، اما برخلاف مقیاس‌پذیری محور X، هر نمونه مسئولیت فقط بخشی از داده‌ها را بر عهده دارد. مسیریاب در جلوی نمونه‌ها، با استفاده از یک ویژگی درخواست، آن را به نمونه مناسب هدایت می‌کند. به عنوان مثال، یک برنامه ممکن است درخواست‌ها را بر اساس userId مسیریابی کند.
</div>

![img_1.png](img_1.png)

<br/>
<div dir="rtl" style="font-size:28px">
3- Y-axis (عمودی) - مقیاس‌پذیری عمودی (Vertical Scaling)
</div>

<br/>

<div dir="rtl" style="font-size:28px">
مقیاس‌پذیری محور X و Z ظرفیت و دسترسی‌پذیری یک برنامه را بهبود می‌بخشند. اما هیچ‌کدام از این روش‌ها مشکل افزایش پیچیدگی توسعه و برنامه را حل نمی‌کنند. برای حل این مشکلات، باید از مقیاس‌پذیری محور Y یا تجزیه عملکردی استفاده کنید. مقیاس‌پذیری محور Y مثل شکل زیر عمل می‌کند: با تقسیم یک برنامه یکپارچه به مجموعه‌ای از سرویس‌ها.
</div>

<br/>

![img_3.png](img_3.png)

<br/>

<div dir="rtl" style="font-size:28px">
تفاوت های بین SOA و Microservice:
</div>

<br/>

<div dir="rtl" style="font-size:28px">
SOA و معماری میکروسرویس‌ها معمولاً از تکنولوژی‌های مختلف استفاده می‌کنند. برنامه‌های SOA معمولاً از تکنولوژی‌های سنگین مانند SOAP و سایر استانداردهای WS* بهره می‌برند. این برنامه‌ها اغلب از یک ESB (Enterprise Service Bus) استفاده می‌کنند که لوله‌ای هوشمند است و شامل منطق کسب‌وکار و پردازش پیام‌ها برای ادغام سرویس‌ها می‌باشد. در مقابل، برنامه‌هایی که با معماری میکروسرویس‌ها ساخته می‌شوند، معمولاً از تکنولوژی‌های سبک و منبع باز استفاده می‌کنند. این سرویس‌ها از لوله‌های ساده مانند پیام‌رسان‌ها یا پروتکل‌های سبک مانند REST یا gRPC برای ارتباط استفاده می‌کنند.

SOA و معماری میکروسرویس‌ها همچنین در نحوه مدیریت داده‌ها تفاوت دارند. برنامه‌های SOA معمولاً از یک مدل داده جهانی و پایگاه‌های داده مشترک بهره می‌برند. در مقابل، همان‌طور که قبلاً ذکر شد، در معماری میکروسرویس‌ها، هر سرویس پایگاه داده خاص خود را دارد. علاوه بر این، همان‌طور که در فصل ۲ توصیف شده است، هر سرویس معمولاً مدلی از دامنه خاص خود را دارد.

تفاوت کلیدی دیگر بین SOA و معماری میکروسرویس‌ها اندازه سرویس‌ها است. SOA معمولاً برای ادغام برنامه‌های بزرگ و پیچیده یکپارچه استفاده می‌شود. اگرچه سرویس‌های موجود در معماری میکروسرویس‌ها همیشه بسیار کوچک نیستند، اما تقریباً همیشه بسیار کوچک‌تر از سرویس‌های SOA هستند. در نتیجه، یک برنامه SOA معمولاً شامل چندین سرویس بزرگ است، در حالی که یک برنامه مبتنی بر میکروسرویس‌ها معمولاً شامل ده‌ها یا صدها سرویس کوچکتر است.
</div>

<br/>

<div dir="rtl" style="font-size:28px">
ساختارهای رایج الگو 
</div>

<br/>

<div dir="rtl" style="font-size:28px">
1- FORCES: نیروها به مسائل و چالش‌هایی گفته می‌شود که باید هنگام حل یک مشکل در یک زمینه خاص مورد توجه قرار گیرند. به عبارت دیگر، وقتی می‌خواهید یک مسئله را در زمینه‌ای مشخص حل کنید، باید به عوامل مختلفی که ممکن است درگیر باشند توجه کنید.

نکته مهم این است که این نیروها می‌توانند با هم در تضاد باشند، یعنی ممکن است نتوانید همه آن‌ها را به‌طور کامل حل کنید. برای مثال، شما ممکن است بخواهید کدی بنویسید که هم کارایی بالایی داشته باشد و هم فهمیدن آن آسان باشد. اما در برخی موارد، کدی که عملکرد بهتری دارد، ممکن است سخت‌تر قابل درک باشد. بنابراین باید تصمیم بگیرید که کدام یک از این نیروها (در اینجا: کارایی یا سادگی) برای شما مهم‌تر است و بر اساس آن عمل کنید.

به طور خلاصه، در هنگام طراحی یک راه‌حل برای یک مسئله خاص، باید نیروها و چالش‌های موجود را به‌طور دقیق بررسی کنید و اولویت‌بندی کنید که کدام یک از آن‌ها برای شما مهم‌تر است.
</div>

<br/>

<div dir="rtl" style="font-size:28px">
2- RESULTING CONTEXT: 
به پیامدهای اعمال آن الگو اشاره دارد. این بخش شامل سه قسمت است:

مزایا: این قسمت به مزایای الگو می‌پردازد، از جمله نیروهایی که با استفاده از این الگو حل شده‌اند. به عبارت دیگر، این قسمت توضیح می‌دهد که چه مشکلاتی با استفاده از این الگو برطرف می‌شوند و چه بهبودهایی حاصل می‌شود.

معایب: این قسمت به معایب الگو می‌پردازد، از جمله نیروهایی که با وجود استفاده از الگو همچنان بدون حل باقی مانده‌اند. به عبارت دیگر، این قسمت به مشکلاتی اشاره می‌کند که با وجود استفاده از الگو همچنان وجود دارند یا حتی ممکن است تشدید شده باشند.

مسائل جدید: این قسمت به مشکلات جدیدی که ممکن است به دلیل اعمال این الگو به وجود آمده باشند، اشاره دارد. به عبارت دیگر، ممکن است استفاده از الگو مشکلات جدیدی ایجاد کند که قبلاً وجود نداشته‌اند.

این بخش از الگو به شما یک دیدگاه کامل‌تر و کمتر جانب‌دارانه از راه‌حل ارائه می‌دهد و به این ترتیب، به شما کمک می‌کند تا تصمیمات بهتری در طراحی بگیرید.
</div>

<br/>

<div dir="rtl" style="font-size:28px">
3- Related Patterns: 
به پیامدهای اعمال آن الگو اشاره دارد. این بخش شامل سه قسمت است:در این سیستم، شما باید تصمیم بگیرید که از چه نوع معماری و الگوهایی برای طراحی استفاده کنید.

1. الگوی پیشرو (Predecessor)
برای شروع، شما باید تصمیم بگیرید که آیا می‌خواهید سیستم را به صورت یک معماری مونولیتیک (Monolithic Architecture) طراحی کنید یا از معماری میکروسرویس‌ها (Microservices Architecture) استفاده کنید. فرض کنید تصمیم می‌گیرید از معماری میکروسرویس‌ها استفاده کنید. این تصمیم به عنوان یک الگوی پیشرو عمل می‌کند، زیرا نیاز به الگوهای بعدی را ایجاد می‌کند.

2. الگوی جانشین (Successor)
وقتی معماری میکروسرویس‌ها را انتخاب کردید، با مشکلاتی مانند کشف سرویس (Service Discovery) مواجه می‌شوید. این مشکل توسط الگوی دیگری به نام الگوی کشف سرویس حل می‌شود که به عنوان الگوی جانشین عمل می‌کند. همچنین، ممکن است نیاز داشته باشید از الگوی Circuit Breaker برای مدیریت خطاهای سرویس‌ها استفاده کنید، که این نیز یک الگوی جانشین است.

3. الگوی جایگزین (Alternative)
اگرچه شما معماری میکروسرویس‌ها را انتخاب کرده‌اید، اما هنوز هم می‌توانید از معماری مونولیتیک به عنوان یک الگوی جایگزین استفاده کنید. این معماری ساده‌تر است و ممکن است برای پروژه‌های کوچک‌تر مناسب‌تر باشد. این دو الگو به عنوان جایگزین یکدیگر عمل می‌کنند و شما باید یکی را انتخاب کنید.

4. الگوی تعمیم‌یافته (Generalization)
فرض کنید که شما می‌خواهید سرویس‌ها را به صورت مجزا در سرورهای مختلف اجرا کنید. الگوی Single Service per Host یک راه‌حل عمومی برای این مشکل است. این الگو می‌گوید هر سرویس باید در یک میزبان جداگانه اجرا شود تا منابع بهینه‌تری استفاده شود.

5. الگوی تخصصی‌شده (Specialization)
حالا اگر تصمیم بگیرید که سرویس‌های خود را در کانتینرها (مانند Docker) اجرا کنید، الگوی Deploy a Service as a Container یک نسخه تخصصی شده از الگوی "خدمات تک سرویس در هر میزبان" است. در این حالت، به جای استفاده از ماشین‌های فیزیکی یا مجازی جداگانه، هر سرویس در یک کانتینر مستقل اجرا می‌شود.

خلاصه
با در نظر گرفتن این مثال‌ها، مشاهده می‌کنید که چگونه الگوها می‌توانند با یکدیگر مرتبط باشند و چگونه انتخاب یک الگو می‌تواند به انتخاب یا نیاز به الگوهای دیگر منجر شود. این روابط به شما کمک می‌کنند تا بهترین راه‌حل را برای مشکلات معماری و طراحی خود انتخاب کنید.

</div>

<br/>


<br/>

<div dir="rtl" style="font-size:28px">
PATTERNS FOR DECOMPOSING:(نحوه تجزیه )
</div>

<br/>


<div dir="rtl" style="font-size:28px">
تقسیم‌بندی بر اساس قابلیت کسب‌وکار که سرویس‌ها را بر اساس قابلیت‌های کسب‌وکار سازماندهی می‌کند، و تقسیم‌بندی بر اساس زیردامنه که سرویس‌ها را بر اساس زیردامنه‌های طراحی مبتنی بر دامنه (DDD) سازماندهی می‌کند.
</div>

<br/>

<div dir="rtl" style="font-size:28px">
1. تقسیم‌بندی بر اساس قابلیت کسب‌وکار
در این روش، سرویس‌ها بر اساس قابلیت‌های اصلی کسب‌وکار سازماندهی می‌شوند. مثلاً در یک فروشگاه آنلاین، برخی از قابلیت‌های کلیدی کسب‌وکار شامل مدیریت موجودی، پردازش سفارشات و مدیریت مشتریان است. هر یک از این قابلیت‌ها می‌تواند به عنوان یک سرویس مستقل در نظر گرفته شود:

سرویس مدیریت موجودی: این سرویس مسئول مدیریت موجودی محصولات است، مثلاً به‌روزرسانی تعداد موجودی، بررسی سطح موجودی محصولات و مدیریت انبارها.
سرویس پردازش سفارشات: این سرویس تمام عملیات مربوط به ثبت و پردازش سفارشات مشتریان را انجام می‌دهد، مثل محاسبه هزینه‌ها و ارسال سفارش.
سرویس مدیریت مشتریان: این سرویس اطلاعات مشتریان، پروفایل‌ها و تراکنش‌های آن‌ها را مدیریت می‌کند.
این تقسیم‌بندی بر اساس توانمندی‌های کسب‌وکار فروشگاه آنلاین انجام شده و سرویس‌ها به طور مستقیم به عملکردهای کلیدی مرتبط هستند.

2. تقسیم‌بندی بر اساس زیردامنه (DDD)
در این روش، سرویس‌ها بر اساس زیردامنه‌های طراحی مبتنی بر دامنه (Domain-Driven Design) سازماندهی می‌شوند. به عنوان مثال در یک سیستم بانکداری، زیردامنه‌های مختلفی وجود دارد که هر کدام به یک جنبه خاص از فعالیت‌های بانکداری مربوط است:

زیردامنه حساب‌ها: این زیردامنه مسئول مدیریت حساب‌های بانکی مشتریان است. عملیات‌هایی مانند ایجاد حساب، مشاهده موجودی و بستن حساب تحت این زیردامنه قرار می‌گیرند.
زیردامنه وام‌ها: این زیردامنه مربوط به فرآیندهای مربوط به وام‌ها و اعتبار است. سرویس‌هایی که درخواست وام، محاسبه نرخ بهره و مدیریت بازپرداخت وام را انجام می‌دهند، در این زیردامنه قرار دارند.
زیردامنه تراکنش‌ها: این زیردامنه برای مدیریت تراکنش‌های مالی بین حساب‌ها است، مانند انتقال وجه بین حساب‌ها، پرداخت‌های آنلاین و گزارش‌دهی تراکنش‌ها.
در این رویکرد، تقسیم‌بندی سرویس‌ها بر اساس منطق دامنه‌های اصلی سیستم انجام می‌شود و هر سرویس به یک زیردامنه خاص از کسب‌وکار مرتبط است.
</div>

<br/>

<div dir="rtl" style="font-size:28px">
COMMUNICATION PATTERNS:(الگوهای ارتباطی)
</div>

<br/>


<div dir="rtl" style="font-size:28px">
<br/>
سبک ارتباط (Communication style): چه نوع مکانیزم IPC باید استفاده کنید؟
<br/>
کشف(Discovery): یک کلاینت چطور می‌تواند آدرس IP یک نمونه سرویس را پیدا کند تا مثلاً یک درخواست HTTP ارسال کند؟
<br/>
قابلیت اطمینان(Reliability): چگونه می‌توانید تضمین کنید که ارتباط بین سرویس‌ها قابل اعتماد است، حتی اگر برخی سرویس‌ها در دسترس نباشند؟
<br/>
پیام‌رسانی تراکنشی(Transactional messaging): چگونه باید ارسال پیام‌ها و انتشار رویدادها را با تراکنش‌های پایگاه داده که داده‌های کسب‌وکار را به‌روزرسانی می‌کنند، یکپارچه کنید؟ 
<br/>
خارجی (External API): چگونه کلاینت‌های برنامه شما با سرویس‌ها ارتباط برقرار می‌کنند؟

</div>

<br/>

![img_4.png](img_4.png)

<div dir="rtl" style="font-size:28px">
1. سبک‌های ارتباطی (Communication Styles)
این گروه به روش‌های مختلفی که میکروسرویس‌ها می‌توانند با هم ارتباط برقرار کنند اشاره دارد. برخی از رایج‌ترین سبک‌ها عبارتند از:

پیام‌رسانی (Messaging): در این روش، میکروسرویس‌ها از طریق ارسال پیام به یکدیگر ارتباط برقرار می‌کنند. این پیام‌ها می‌توانند به صورت همزمان یا ناهمزمان ارسال شوند.
** فراخوانی رویه از راه دور (Remote Procedure Invocation):** در این روش، یک میکروسرویس به طور مستقیم به یک میکروسرویس دیگر درخواست می‌دهد تا یک عملیات را انجام دهد.
Domain-specific: این سبک به الگوهای ارتباطی اشاره دارد که برای حوزه‌های خاص طراحی شده‌اند و ممکن است شامل پروتکل‌ها یا فرمت‌های داده‌های سفارشی باشند.
2. قابلیت اطمینان (Reliability)
این گروه به مکانیزم‌هایی اشاره دارد که برای اطمینان از قابلیت اطمینان ارتباط بین میکروسرویس‌ها استفاده می‌شوند. یکی از مهم‌ترین الگوها در این گروه، قطع‌کننده (Circuit Breaker) است که از فراخوانی‌های مکرر به یک سرویس ناموفق جلوگیری می‌کند تا از بارگذاری بیش از حد سیستم جلوگیری شود.

3. کشف سرویس (Discovery)
این گروه به روش‌هایی اشاره دارد که میکروسرویس‌ها می‌توانند یکدیگر را پیدا کنند. برخی از روش‌های رایج عبارتند از:

کشف سرویس سمت کلاینت: در این روش، کلاینت‌ها به طور فعال به دنبال سرویس‌های مورد نیاز خود می‌گردند.
کشف سرویس سمت سرور: در این روش، یک سرویس مرکزی لیستی از تمام سرویس‌های موجود را نگهداری می‌کند و کلاینت‌ها برای پیدا کردن سرویس‌ها به این سرویس مرکزی مراجعه می‌کنند.
ثبت نام خودکار: سرویس‌ها می‌توانند به طور خودکار در یک فهرست سرویس مرکزی ثبت نام کنند.
ثبت نام توسط شخص ثالث: یک شخص ثالث می‌تواند سرویس‌ها را در یک فهرست سرویس مرکزی ثبت نام کند.
4. الگوهای ارتباطی خاص حوزه (Domain-specific Communication Patterns)
این گروه به الگوهای ارتباطی اشاره دارد که برای حوزه‌های خاص طراحی شده‌اند و ممکن است شامل پروتکل‌ها یا فرمت‌های داده‌های سفارشی باشند.

5. درگاه‌های API (API Gateways)
درگاه‌های API به عنوان یک لایه واسط بین کلاینت‌ها و میکروسرویس‌ها عمل می‌کنند. آن‌ها مسئولیت‌هایی مانند مسیریابی درخواست‌ها، مدیریت احراز هویت و مجوز، و تبدیل پروتکل‌ها را بر عهده دارند.
</div>

<br/>





